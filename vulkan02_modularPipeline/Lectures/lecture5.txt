Vulkan Game Engine Lecture 5

What is a Swap Chain?
* The graphics pipeline outputs images to a framebuffer.
* The framebuffer can have different attachments (color buffer, depth buffer, stencil buffer).
* The swap chain uses this framebuffer objects to read from them and display them on the screen.

Double Buffering vs Triple Buffering
* Modern OS uses at least two buffers at once.
* The front buffer is the one currently being displayed on the screen.
* The back buffer is the one being rendered to by the GPU.
* The swap chain handles displays, by swapping the front and back buffers at the appropriate time
	just prior to the vertical sync.
* Vsync is the moment at which the display begins drawing the new image and is synchronized 
	with the monitor's refresh rate. If the refresh rate is 60Hz, the vsync happens 60 times per second.
	Every 16.6ms the vsync occurs and front and back buffers are swapped.
* Turning off vsync can lead to screen tearing. Tearing occurs when the front buffer is updated
	while the display is in the middle of drawing it. This can lead to parts of two different frames
	being displayed at once.

* Each framebuffer requires its own attachments, except for those which can be shared
	such as depth and stencil buffers.

* Once we finish rendering the frame, our device needs to wait until the next vsync event
	before swapping the buffers. This can lead to idle GPU time, which is wasted performance.
* Triple buffering can help with this. Instead of having one back buffer, we have two back buffers.

* G-Sync and Free-Sync are technologies that allow the monitor to adjust its refresh rate to match
	the game's frame rate.

Swap Chain Present Modes - FIFO vs Mailbox vs Immediate
* FIFO is the standard present mode. It is similar to a queue. The display takes images from the front
	of the queue and the program adds rendered images to the back of the queue. If the queue is full,
	the program has to wait until there is space in the queue.

* Even with triple buffering, if the program renders frames faster than the display can handle,
	the program will still have to wait (GPU Idle time).
* Mailbox is an alternative present mode. The GPU is never Idle because it'll discard and override the
	older back buffers if the queue is full. This can lead to lower latency and higher frame rates.

* Mailbox must be supported by the device and we have to verify it before using, 
	otherwise we have to use FIFO (which is guaranteed to be supported).

* As the GPU never idles, this leads to higher power consumption. This is something to consider
	for mobile devices (you typically want to use FIFO on mobile devices).

* The Immediate present mode is another option. The program does not wait for the vsync event
	and the image is displayed immediately. This can lead to screen tearing and is generally not recommended.
  It is usually supported and is effectively the same as turning vsync off.

// learncpp.com
// #include <memory> // for std::unique_ptr
// smart pointers - a smart pointer simulates a regular pointer while providing additional features, 
// such as automatic memory management, so we're no longer responsible for calling new and delete
// e.g. creating and destroying objects on the heap.

Implementing createPipelineLayout()
* a pipeline set layout is used to pass data other than our vertex data to the shaders 
	(e.g. textures, uniform buffers, etc.).
* push constants are a way to pass a small amount of data to shaders to our shader programs.

Implementing createPipeline()
* when creating the pipeling config info, it's important to pass the swapchain's width and height
	as it doesn't necessarily match the window's width and height. On high pixel density displays,
	the window measured in screen coordinates is smaller than the number of pixels it contains.

Brief Introduction to Render Passes
* a render pass describes the structure and format of our framebuffer objects and their attachments.
* for the getRenderPass() function, we receive a render pass object that has the attachments vector
	with index 0 being the color buffer and index 1 being the depth buffer.

* It may help to think of a render pass as a blueprint that tells the graphics pipeline object what
	layout to expect for the output framebuffer. That way, when is time to render, our graphics
	pipeline is already prepared to output to our framebuffer, as long as the framebuffer matches
	the layout specified in the render pass.
* For more complex render passes, we can have multiple subpasses grouped within a single render pass.

What is a Command Buffer?
* We can't execute commands directly in Vulkan, but rather we want to record them into a command buffer
and then submit the command to a device queue for execution.

Example: Record this into a command buffer
Start Render Pass
1) bind pipeline 1
2) bind texture 4
3) draw 100 vertices
End Render Pass

Buffer #1 submit to device graphics queue and outputs to framebuffer 1.

* Command buffers allow a sequence of commands to be recorded once and then reused for multiple frames.
(There's no need to repeat draw commands for each frame like OpenGL).

Option 1: Record command buffers once at initialization, and then reuse for each frame.
Option 2: Record command buffer every frame, just before submitting.

* Command Buffer Lifecycle
* When the command is submitted, it enters 'Pending' state. It's invalid to reuse a command
that is already in the pending state. It needs to first complete before being resubmitted.

* Our current swap chain limits us to submit at most two command buffers to the device's
graphics queue at once (MAX_FRAMES_IN_FLIGHT = 2). After two command buffers have been submitted
the CPU will block the next call to the vkAcquireNextImageKHR().
* When the GPU has finished executing one of the command buffers it will signal the CPU to carry on.

* It's possible to use more than 2 framebuffers with only 2 command buffers.
* When recording a start render pass command, we must specify the target output framebuffer
so if this is the case, we need to re-record a command buffer every frame.

Command Buffer Allocation

* First we resize the command buffer vector. The swap chain image count will be likely 2 or 3 depending
if your device supports double or triple buffering.

* We create an structure to allocate our command buffer.
* There are two types of CB's - primary and secondary.
* Primary CB - Can be submitted for a queue for execution but can't be by other command buffers.
* Secondary CB - Can't be submitted but can be called by other CB's.

* Command pools are opaque objects that command buffer memory is allocated from. An app may need to create
and destroy commands buffers frequently so to reduce resource creation costs vulkan has us to allocate and
free command buffers from command pools.

* VK_SUBPASS_CONTENTS_INLINE
* Signals that the subsequent render pass cmds will be directly embedded in the primary cmd buffer itself,
and that no secondary cmd buffers will be used.

* VK_SUBPASS_CONTENTS_SECONDARY
* Signals that render pass commands will be executed from secondary command buffers.

* There is no mixing allowed. We can't have a render pass using INLINE and SECONDARY commands at the same time.


// vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);
* Other options are:
	VK_PIPELINE_BIND_POINT_COMPUTE and VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR

// vkCmdDraw(commandBuffers[i], 3, 1, 0, 0);
* 3 is vertex count
* 1 is number of instances
* You can use multiple instances to draw particle systems (maybe GPU instancing also?).
* 0, 0 is offset